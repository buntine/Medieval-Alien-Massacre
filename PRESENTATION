Notes for my presentation at the functional programmers meetup.

Me
  - Andrew Buntine
  - Work for HHD as lead developer, predominantly Ruby/Rails.
    - Some internal with in Python and Clojure.
  - Interested in FP for a few years, mostly Lisp.
  - Self-taught
  - A Schemer
  - Interested in programming language theory and design, but admittedly find it mind-numbing

Text-based gaming
  - Popular from 1970 onwards.
  - The user interacts with the terminal by typing commands.
  - Early successes included Zork, Adventure! and Dunnet.
  - Relatively easy to write, but can be complex (language parsing, etc).
  - Super fun!
    - Total control over the story.
    - No need for artistic skill.
    - Add new commands at will.

Medieval Alien Massacre
  - Written in clojure, a LISP for the JVM.
  - Currently about 1200 lines - probably my largest lisp project.
  - A hobby project, inspired by Dunnet (written in emacs LISP).
  - All of the hard stuff is done, but the story is incomplete.

...Demonstration...

Who is familiar with LISP?
  - Give 15 minute intro to Clojure.
    - Released in 2007, but relatively unknown until 2009-ish.
    - Runs on the JVM.
      - Compiles to Java bytecode
      - Gets GC for free from the JVM.
      - So you get real Java interop.
        - You can use Java libraries.
        - You can write part/all of your app in Clojure and use it in Java projects.
    - Is a real LISP
      - Maintains homoiconicity, code is data - no separate syntax for code and data.
      - S-Expressions
      - Dynamically-typed
      - Not Object Oriented (as generally perceived - that is inherently imperative)
    - It is functional, but not purely a-la Haskell.
      - Side-effects must be encapsulated
    - A Lisp-1
      - Lexically scoped
      - There is no separate namespace for functions (looks more like Scheme than Common Lisp)
    - Has literal syntax for many data structures (not just lists)
      - Maps, Sets and Vectors
      - First class
      - Each has unique semantics
        - Vectors have O(1) lookup, grow at end
        - Lists are singly-linked, drow and front
      - All implement an iSeq interface, and thus have great interop
        - So library functions are generic: conj, etc.
        - Including string.
      - They are functions of their keys (really cool)
        - ([1 2 3 4 5] 3) ; --> 4
        - (:name {:age 25 :name "Andrew"}) ; --> "Andrew"
        - ({:age 25 :name "Andrew"} :name) ; --> "Andrew"
      - All/most are immutible
        - Modifications generate cheap copies.
    - It goes further than older lisps and does not try to be code-compatible.
      - car = first, cdr = rest
    - Functions are first-class (real closures, lambda, etc)
      - Support variable arity
        - Multiple function bodies
        - A bit like pattern matching, but matches arity (number of arguments) not type
    - Emphasis on higher-order functions and recursion over side-effect based looping, etc.
    - Does not have TCO (because JVM does not have it)
      - But has a work-around (loop..recur)
    - Supports lazy (infinite) sequences
      - Not calculated until request
    - Complex Macro system
   - Simplifies concurrent programming
    - Some examples:
      - Simple forms:
        
        (list 1 2 3)
        (+ 1 2 3)
        (if (= (+ 1 2) 3) :guilty :innocent)

        (def n 1)
        ((if (< n 2) * +) 10 10) ; --> 100

        (let [a 2
              b :cool
              c a]
          c) ; --> 2

        (let [[a b & c :as d] [1 2 3 4 5]]
          [a b c d]) ; --> [1 2 (3 4 5) [1 2 3 4 5]]

      - Write function and execute.

        ; Recursive fact, grows stack. Bad.
        (defn fact [n]
          (if (<= n 1)
            n
            (* n (fact (- n 1)))))

        (fact 5) ; --> 120
        (fact 20000) ; --> Stack Overflow!!

        ; Iterative fact, stack won't grow.
        (defn fact
          ([n] (fact n 1))
          ([n t]
            (if (<= n 1)
              t
              (recur (- n 1) (* t n)))))

        (fact 20000) ; --> Very big number

      - Lambda, anonymous functions

        ((fn [n] (+ n 1)) 10) ; --> 11

        #(+ %1 10) ; --> Adds 10 to argument. A macro that expands to (fn [n] (+ n 10))

      - Higher-order function.

        (map (fn [n] (* n 2)) [1 2 3 4]) ; --> (2 4 6 8) ; Seq

        (into [] (map #(* %1 2) [1 2 3 4])) ; --> [ 2 4 6 8] ; Vector

        (reduce + [1 2 3 4]) ; --> 10

      - Closure

        (defn make-adder [n]
          (fn [i] (+ n i)))

        (def plus10 (make-adder 10))

        (plus10 30) ; --> 40

      - Software transactional memory

        (def n (ref 0)) ; Ensures single location for value.

        (ref-set n 1) ; --> Error! Must be changed within a transaction.

        (dosync
          (ref-set n 1)) ; --> 1

        n  ; --> #<Ref:23af65>
        @n ; --> 1  ; Deref reader macro

      - Basic Java interop.
        - Clojure strings are Java strings.
        - .instanceMethodName form.

          (.toUpperCase "Hello") ; --> "HELLO")
          (.getName Boolean) ; --> "java.lang.Boolean"

        - The '.' special form

          (. "hello" length) ; --> 5

        - doto macro for executing several functions in succession on a Java object

          (doto (new java.util.HashMap) (.put "a" 1) (.put "b" 2)) ; --> {"a" 1 "b" 2}

How it's written
  - Show main files and explain role of each.
  - Open core and see how things get going.
  - I use STM for managing side-effects.
  - Show language parsing.
    - Can get potentially complicated:
      - Give blue key to old man.
      - Give the fucking blue key to that old man over there.
  - Change the first room of the game.
    - Modify description
    - Add new object.
