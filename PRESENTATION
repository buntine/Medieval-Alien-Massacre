Notes for my presentation at the functional programmers meetup.

Me
  - Andrew Buntine
  - Work for HHD as lead developer, predominantly Ruby/Rails.
    - Some internal with in Python and Clojure.
  - Interested in FP for a few years, mostly Lisp.
  - A Schemer
  - Interested in programming language theory and design, but admittedly find it mind-numbing

Text-based gaming
  - Popular from 1970 onwards.
  - The user interacts with the terminal by typing commands.
  - Early successes included Zork, Adventure! and Dunnet.
  - Relatively easy to write, but can be complex (language parsing, etc).
  - Super fun!
    - Total control over the story.
    - No need for artistic skill.
    - Add new commands at will.

Medieval Alien Massacre
  - Written in clojure, a LISP for the JVM.
  - Currently about 1200 lines - probably my largest lisp project.
  - A hobby project, inspired by Dunnet (written in emacs LISP).
  - All of the hard stuff is done, but the story is incomplete.

...Demonstration...

Who is familiar with LISP?
  - Give 5 minute intro to Clojure.
    - Released in 2007, but relatively unknown until 2009-ish.
    - Compiles to Java bytecode, so you can run it on the JVM.
      - So you get real Java interop.
        - You can use Java libraries.
        - You can write part/all of your app in Clojure and use it in Java projects.
    - Is a real LISP
      - Maintains homoiconicity, code is data - no separate syntax for code and data.
      - S-Expressions.
    - It is functional, but not purely a-la Haskell.
      - Side-effects must be encapsulated
    - A Lisp-1
      - Lexically scoped
      - There is no separate namespace for functions (looks more like Scheme than Common Lisp)
    - Has literal syntax for many data structures (not just lists)
      - Maps, Sets and Vectors
      - First class
      - Each has unique semantics
      - They are functions of their keys (really cool)
      - All/most are immutible
        - Modifications generate cheap copies.
    - It goes further than older lisps and does not try to be code-compatible.
    - Functions are first-class (real closures, lambda, etc)
    - Emphasis on higher-order functions and recursion over side-effect based looping, etc.
    - Supports lazy (infinite) sequences
      - Not calculated until request
    - Complex Macro system
    - Does not have TCO (because JVM does not have it)
      - But has a work-around (loop..recur)
    - Simplifies concurrent programming
    - Some examples:
      - Simple forms:
        
        (list 1 2 3)
        (+ 1 2 3)
        (if (= (+ 1 2) 3) :guilty :innocent)

      - Write function and execute.

        ; Recursive fact, grows at 0(n)
        (defn fact [n]
          (if (<= n 1)
            n
            (* n (fact (- n 1)))))

        (fact 5) ; --> 120

      - Lambda

        ((fn [n] (+ n 1)) 10) ; --> 11

        #(+ %1 10) ; --> Adds 10 to argument. A macro that expands to (fn [n] (+ n 10))

      - Higher-order function.
      - Basic Java interop.

How it's written
  - Show main files and explain role of each.
  - Open core and see how things get going.
  - Show language parsing.
    - Can get potentially complicated:
      - Give blue key to old man.
      - Give the fucking blue key to that old man over there.
  - Change the first room of the game.
    - Modify description
    - Add new object.
